什么是数据结构
•数据对象在计算机中的组织方式
•数据对象必定与一系列加在其上的操作相关联
•完成这些操作所用的方法就是算法

抽象数据类型(Abstract Data Type)
•数据类型
    •数据对象集
    •数据集合相关联的操作集
•抽象:描述数据类型的方法不依赖与具体实现
    •与存放数据的机器无关
    •与数据存储的物理结构无关
    •与实现操作的算法和编程语言无关

什么是好的算法？
•空间复杂度S(n):根据算法写成的程序在执行时占用存储单元的大小
•时间复杂度T(n):根据算法写成的程序在执行时耗费时间的长度
•在分析一般算法的效率时，我们经常关注下面两种复杂度
    •最坏情况复杂度Tworst(n)☆
    •平均复杂度Tavg(n)

复杂度的渐进表示法
•T(n)=O(f(n))表示存在常数C>0,n0>0使得当n>=n0时有T(n)<=C*f(n)
•T(n)=Ω(f(n))表示存在常数C>0,n0>0使得当n>=n0时有T(n)》=C*f(n)

复杂度分析小窍门
•若两段算法分别有复杂度T1(n)=O(f1(n))和T2(n)=O(f2(n))
    •T1(n)+T2(n)=max(O(f1(n)),O(f2(n)))
    •T1(n)*T2(n)=O(f1(n)*f2(n))
•一个for循环的时间复杂度等于循环次数乘以循环内代码的复杂度
•if-else结构的复杂度取决于if的条件和两个分支部分的复杂度，总体复杂度取三者最大
算法(Algorithm)
•一个有限指令集
•接受一些输入
•产生输出
•在有限步骤后终止
•每一条指令必须
    •有充分明确的目标，不可以有歧义
    •计算机能处理的范围之内
    •描述应不依赖与任何一种计算机语言以及具体的实现手段

多项式表示问题的启示：
1.同一个问题可以有不同方式为表示方法
2.有一类共性问题：有序线性序列的组织和管理
线性表：由同类型数据元素构成有序序列的线性结构
    •表中元素个数称为线性表的长度
    •线性表没有元素时，称为空表
    •表起始位置称为表头，结束位置称为表尾

线性表的顺序存储实现
•利用数组的连续存储空间顺序存放线性表的各元素
•不要求逻辑上相邻的两个元素物理上也相邻，通过链建立起数据元素之间的逻辑关系
 插入、删除不需要移动数据元素，只需要修改链

广义表：
    •广义表是线性表的推广
    •对于线性表而言，n个元素都是基本的单元素
    •广义表中，这些元素不仅可以是单元素，也可以是另一个广义表

多重链表：链表中的结点可能同时隶属于多个链表
    •多重链表中结点的指针域会有多个，如前面例子包含Next和SubList两个指针域
    •但包含两个指针域的链表不一定是多重链表，比如双向链表不是多重链表
    •多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储




树与树的表示
•客观世界中许多事物存在层次关系
•分层次组织在管理上有更高的效率

查找
•根据某个给定的关键字K,从集合R中找出关键字与K相同的记录
•静态查找：集合中记录是固定的
    •没有插入和删除操作，只有查找
•动态查找：集合中记录是动态变化的
    •除查找，还可能发生插入和删除

方法1：顺序查找
•顺序查找的一种实现(无哨兵)
int SequentialSearch(List Tb1,ElementType K)
{/*在Element[1]-Element[n]中查找关键字为K的数据*/
    int i;
    for(i=Tb1->Length;i>0 && Tb1->Element[i]!=K;i--);
    return i;/*查找成功返回所在单元下标*/
}

•有哨兵
int SequentialSearch(List Tb1,ElementType K)
{/*在Element[1]-Element[n]中查找关键字为K的数据*/
    int i;
    Tb1->Element[0] = K;/*建立哨兵*/
    for(i=Tb1->Length;Tb1->Element[i]!=K;i--);
    return i;/*查找成功返回所在单元下标*/
}
•顺序查找算法的时间复杂度是O(n)
方法2：二分查找(Binary Search)
假设n个数据元素的关键字满足有序(比如：小到大)
    k1<k2<...<kn
并且是连续存放(数组)，那么可以进行二分查找

int BinarySearch(List Tb1,ElementType K)
{/*在表Tb1中查找关键字为K的数据元素*/
    int left,right,mid,NoFound = -1;
    left = 1;                    /*初始左边界*/
    right = Tb1->Length;         /*初始右边界*/
    while(left <= right){
        mid = (left + right)/2;  /*计算中间元素坐标*/
        if(K < Tb1->Element[mid])        right = mid - 1;  /*调整右边界*/
        else if(K > Tb1->Element[mid])   left = mid + 1;   /*调整左边界*/
        else return mid; /*查找成功,返回数据元素的下标*/
    }
    return NoFound;  /*查找不成功，返回-1*/
}