树与树的表示
•客观世界中许多事物存在层次关系
•分层次组织在管理上有更高的效率

查找
•根据某个给定的关键字K,从集合R中找出关键字与K相同的记录
•静态查找:集合中记录是固定的
    •没有插入和删除操作，只有查找
•动态查找:集合中记录是动态变化的
    •除查找，还可能发生插入和删除

方法1:顺序查找
•顺序查找的一种实现(无哨兵)
int SequentialSearch(List Tb1,ElementType K)
{/*在Element[1]-Element[n]中查找关键字为K的数据*/
    int i;
    for(i=Tb1->Length;i>0 && Tb1->Element[i]!=K;i--);
    return i;/*查找成功返回所在单元下标*/
}

•有哨兵
int SequentialSearch(List Tb1,ElementType K)
{/*在Element[1]-Element[n]中查找关键字为K的数据*/
    int i;
    Tb1->Element[0] = K;/*建立哨兵*/
    for(i=Tb1->Length;Tb1->Element[i]!=K;i--);
    return i;/*查找成功返回所在单元下标*/
}
•顺序查找算法的时间复杂度是O(n)
方法2:二分查找(Binary Search)
假设n个数据元素的关键字满足有序(比如:小到大)
    k1<k2<...<kn
并且是连续存放(数组)，那么可以进行二分查找

int BinarySearch(List Tb1,ElementType K)
{/*在表Tb1中查找关键字为K的数据元素*/
    int left,right,mid,NoFound = -1;
    left = 1;                    /*初始左边界*/
    right = Tb1->Length;         /*初始右边界*/
    while(left <= right){
        mid = (left + right)/2;  /*计算中间元素坐标*/
        if(K < Tb1->Element[mid])        right = mid - 1;  /*调整右边界*/
        else if(K > Tb1->Element[mid])   left = mid + 1;   /*调整左边界*/
        else return mid; /*查找成功,返回数据元素的下标*/
    }
    return NoFound;  /*查找不成功，返回-1*/
}

11个元素的二分查找判定树
•判定树上每个结点需要的查找次数刚好为该结点所在的层数
•查找成功时查找次数不会超过判定树的深度
•n个结点的判定树的深度为[log2n]+1
•ASL

树的定义
•树：n(n>=0)个结点构成的有限集合
 当n=0时,称为空树:
 对于任一棵非空树,它具备以下性质:
1.树中有一个称为根(root)的特殊结点,用r表示
2.其余结点可分为m个互不相交的有限集T1,T2,...,Tm,其中每个集合本身又是一棵树,称为原来树的子树(SubTree)

•树与非树
1.子树是不相交的
2.除了根节点外,每个结点有且仅有一个父结点
3.一个N个结点的数有N-1条边

•树的一些基本术语
1.结点的度:结点的子树个数
2.树的度:树的所有结点中最大的度数
3.叶结点:度为0的结点
4.父结点:有子树的结点是其子树的根结点的父结点
5.子结点:若A结点是B结点的父结点,则称B结点是A结点的子结点,子结点也称孩子结点
6.兄弟结点:具有同一父结点的各结点彼此是兄弟结点
7.路径和路径长度:从结点n1到nk的路径为一个结点序列n1,...,nk,ni是ni+1的父结点,路径所包含边的个数为路径的长度
8.祖先结点:沿树根到某一结点路径上的所有结点都是这个结点的祖先结点4
9.子孙结点:某一结点的子树中的所有结点是这个结点的子孙
10.结点的层次:规定根结点在1层,其他任一结点的层数是其父结点的层数加1
11.树的深度:树中所有结点的最大层次是这棵树的深度

•二叉树的定义
二叉树:一个有穷的结点集合
    这个集合可以为空
    若不为空,则它是由根结点和称为其左子树和右子树的两个不相交的二叉树组成
二叉树具体有五种基本形态
二叉树的子树有左右顺序之分
•特殊二叉树
斜二叉树
完美二叉树
完全二叉树
•二叉树几个重要性质
一个二叉树第i层的最大结点数为2^(i-1)
深度为k的二叉树有最大结点总数为2^k-1
对任何非空二叉树T,若n0表示叶结点的个数,n2是度为2的非叶结点个数,na那么两者满足关系n0=n2+1

•二叉树的抽象数据类型定义
类型名称:二叉树
数据对象集:一个有穷的结点集合
          若不为空,则由根结点和其左右二叉子树组成
操作集:
Boolean IsEmpty(BinTree BT):判别BT是否为空
void Traversal(BinTree BT):遍历,按某顺序访问每个结点
BinTree CreatBinTree():创建一个二叉树
常用的遍历方法有:
void PreOrderTraversal(BinTree BT):先序——根、左子树、右子树
void InOrderTraversal(BinTree BT):中序——左子树、根、右子树
void PostOrderTraversal(BinTree BT):后序——左子树、右子树、根
void LevelOrderTraversal(BinTree BT):层次遍历,从上到下、从左往右

•二叉树的存储结构
1.顺序存储结构
完全二叉树:按从上至下、从左往右顺序存储n个结点的完全二叉树的父子关系
非根节点的父结点的序号是[i/2]
结点的左孩子结点的序号是2i
结点的右孩子结点的序号是2i+1
一般二叉树:补全树结构,但会造成空间浪费
2.链表存储
typedef struct TreeNode *BinTree;
typedef BinTree Position;
struct TreeNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}

•二叉树的遍历
(1)先序遍历
遍历过程为:
①访问根结点
②现需遍历其左子树
③先序遍历其右子树

(2)中序遍历
1.中序遍历其左子树
2.访问根结点
3.中序遍历其右子树

(3)后序遍历
1.后序遍历其左子树
2.后序遍历其右子树
3.访问根结点

先序、中序和后序遍历过程:遍历过程中经过结点的路线一样,只是访问各节点的时机不同

•二叉树的非递归遍历
非递归算法实现的基本思路:使用堆栈

中序遍历非递归遍历算法
1.遇到一个结点,就把它圧栈,并去遍历它的左子树
2.当左子树遍历结束后,从栈顶弹出这个结点并访问它
3.然后按其右指针再去中序遍历该结点的右子树

•层序遍历
二叉树遍历的核心问题:二维结构的线性化
1.从结点访问其左右儿子结点
2.访问左儿子后,右儿子结点怎么办?
    需要一个存储结构保存暂时不访问的结点
    存储结构:堆栈、队列
1.从队列中取出一个元素
2.访问该元素所指结点
3.若该元素所指结点的左右孩子结点非空,则将其左右孩子的指针顺序入队

•二元运算表达式树及其遍历
三种遍历可以得到三种不同的访问结果
先序遍历得到前缀表达式
中序遍历得到中缀表达式(中缀表达式会受到运算优先级的影响)加括号
后序遍历得到后缀表达式

由两种遍历序列确定二叉树
答案是:必须要有中序遍历
现需和中序遍历序列来确定一颗二叉树
1.根据先序遍历序列第一个结点确定根结点
2.根据根结点在中序遍历序列中分割出左右两个子序列
3.对左子树和右子树分别递归使用相同的方法继续分解

二叉搜索树的插入
关键是要找到元素应该插入的位置,可以采用与Find类似的方法


二叉搜索树的删除
考虑三种情况:
1.要删除的是叶结点,直接删除,并再修改其父结点指针,置为NULL
2.要删除的结点只有一个孩子结点:将其父结点的指针指向要删除结点的孩子结点
3.要删除的结点有左右两颗子树:用另一节点代替被删除结点:右子树的最小元素或者左子树的最大元素







